#pragma config(Motor,  port1,           M1,            tmotorVex393TurboSpeed_MC29, openLoop) // LeftBase
#pragma config(Motor,  port2,           M2,            tmotorVex393TurboSpeed_MC29, openLoop) // RightArm
#pragma config(Motor,  port3,           M3,            tmotorVex393TurboSpeed_MC29, openLoop) // LeftBase
#pragma config(Motor,  port4,           M4,            tmotorVex393TurboSpeed_MC29, openLoop) //
#pragma config(Motor,  port5,           M5,            tmotorVex393TurboSpeed_MC29, openLoop) // RightBase
#pragma config(Motor,  port6,           M6,            tmotorVex393TurboSpeed_MC29, openLoop) // Gripper
#pragma config(Motor,  port7,           M7,            tmotorVex393TurboSpeed_MC29, openLoop) // BellyLoader
#pragma config(Motor,  port8,           M8,            tmotorVex393TurboSpeed_MC29, openLoop) // BellyLoader
#pragma config(Motor,  port9,           M9,            tmotorVex393TurboSpeed_MC29, openLoop) // LeftArm
#pragma config(Motor,  port10,          M10,           tmotorVex393TurboSpeed_MC29, openLoop) // RightBase
#pragma config(Sensor, in1,             belly_angle,   sensorPotentiometer)
#pragma config(Sensor, in2,             arm_angle,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,           jumper,        sensorDigitalIn)  // Jumper to choose direction
#pragma config(Sensor, dgtl12,          auto_mode_jumper,        sensorDigitalIn) // Jumper to choose which auto routine to exec


//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void basemotor(short left, short right) {
	motor[M3] = left;
	motor[M1] = left;
	motor[M10] = right;
	motor[M5] = right;
}

void bellymotor(short stimulus) {
	short sat = stimulus > 127 ? 127 : (stimulus < -127 ? -127 : stimulus);
	int kBellyDownPot = 4000;
  int kBellyUpPot = 2275;
  if (stimulus < 0 && SensorValue[belly_angle] < kBellyUpPot) {
  	sat = 0;
  }
	motor[M7] = -1*sat; motor[M8] = sat;
}

void pre_auton()
{
	return;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
#define ARM_MOTOR_ZERO {motor[M2] = motor[M9] = 0;};

//do not set arm motor power to 127, otherwise it will thud and change alignment
#define ARM_MOTOR_DOWN {motor[M2] = -64; motor[M9] = 64;};
#define ARM_MOTOR_UP {motor[M2] = 64; motor[M9] = -64;};

#define BASE_MOTOR_FWD basemotor(127, -127);
#define BASE_MOTOR_BKD basemotor(-127, 127);
#define BASE_MOTOR_ZERO basemotor(0, 0);
#define BASE_MOTOR_CLOCKWISE basemotor(sign*127, sign*127);
#define BASE_MOTOR_COUNTERCLOCKWISE basemotor(-127*sign, -127*sign);

#define BELLY_MOTOR_DOWN {motor[M7] = -127; motor[M8] = 127;}
#define BELLY_MOTOR_UP {motor[M7] = 127; motor[M8] = -127;}
#define BELLY_MOTOR_ZERO {motor[M7] = motor[M8] = 0;}

#define CLAW_MOTOR_OPEN {motor[M6] = 127;}
#define CLAW_MOTOR_ZERO {motor[M6] = 0;}

void auto_static_goal()
{
	BASE_MOTOR_BKD
	sleep(250);
	BASE_MOTOR_ZERO
	ARM_MOTOR_UP
	sleep(1300);
	ARM_MOTOR_ZERO
	sleep(500);
	// cone is on static
	CLAW_MOTOR_OPEN
	sleep(500);
	ARM_MOTOR_DOWN
	sleep(500);
	CLAW_MOTOR_ZERO
	ARM_MOTOR_ZERO
	BASE_MOTOR_FWD
	sleep(500);
	BASE_MOTOR_ZERO
}

void auto_mobile_goal()
{
short sign = SensorValue[jumper] ? -1 : 1;
ARM_MOTOR_UP
sleep(1000);
ARM_MOTOR_ZERO

// arm should have been vertical now.

BELLY_MOTOR_DOWN
sleep(1300);
BELLY_MOTOR_ZERO

BASE_MOTOR_FWD
sleep(1800);
BASE_MOTOR_ZERO

// goal is picked

BELLY_MOTOR_UP
sleep (1700);
BELLY_MOTOR_ZERO

// goal is in the belly

ARM_MOTOR_DOWN
BASE_MOTOR_BKD
sleep(1500);

BASE_MOTOR_ZERO
sleep(200);
ARM_MOTOR_ZERO
// cone is now on the goal

BASE_MOTOR_CLOCKWISE
sleep(700);
BASE_MOTOR_BKD
sleep(500);
BASE_MOTOR_ZERO
// Should be at the bump here

BASE_MOTOR_FWD
CLAW_MOTOR_OPEN
ARM_MOTOR_UP
sleep(500);
CLAW_MOTOR_ZERO
BASE_MOTOR_CLOCKWISE
sleep(650);
ARM_MOTOR_ZERO

BASE_MOTOR_FWD
sleep(2000);
BASE_MOTOR_ZERO

BELLY_MOTOR_DOWN
sleep(1700);
BELLY_MOTOR_ZERO

BASE_MOTOR_BKD
sleep(1500);
BASE_MOTOR_ZERO
}

task autonomous() {
	if (SensorValue[auto_mode_jumper]) {
		auto_mobile_goal();
  } else {
    auto_static_goal();
  }
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

short nonlinear(short val) {
	int square = val * abs(val);
	return (short) square / 127;
}

#define BELLY_POT_REST 725 // value of pot when loader is all the way back
#define BELLY_POT_FRONT 3275 // value of pot when loader is all the way front
#define BELLY_POT_MID  2000
#define BELLY_POT_

int kArmUp = 2048;
void raise_arm_halfway() {
	// Read arm potentiometer
	int iterations = 0;
	while(iterations < 200) {
		sleep(10);
		short voltage = (kArmUp - SensorValue[arm_angle]) * 100.0/kArmUp;
		{motor[M2] = voltage; motor[M9] = -1*voltage;};
		iterations = iterations + 1;
	}
}

task usercontrol()
{
	//short target_pot = BELLY_POT_MID;
	// User control code here, inside the loop
	while (true)
	{
		// This is the main execution loop for the user control program.
		// Each time through the loop your program should update motor + servo
		// values based on feedback from the joysticks.

		// ........................................................................
		// Insert user code here. This is where you use the joystick values to
		// update your motors, etc.
		// ........................................................................

		// Remove this function call once you have "real" code.
		//UserControlCodePlaceholderForTesting();

		// Chassis motors
		short DEAD_ZONE = 15;
		short left;
		short right;
		short ch3 = vexRT[Ch3];// + vexRT[Ch3Xmtr2];
		short ch1 = vexRT[Ch1];// + vexRT[Ch1Xmtr2];

		if (abs(ch1) < DEAD_ZONE) {
			ch1 = 0;
		}

		if (abs(ch3) < DEAD_ZONE) {
			ch3 = 0;
		}
		short slow_factor = 1;
		ch1 = ch1 / slow_factor; // to make turning slower

		left = nonlinear(ch1 + ch3);
		right = nonlinear(ch1 - ch3);

		motor[M3] = left;
		motor[M1] = left;
		motor[M10] = right;
		motor[M5] = right;

		// BellyLoader motor
		if (vexRT[Btn6U] == 1 || vexRT[Btn6UXmtr2]) {
			bellymotor(100);
		} else if (vexRT[Btn6D] == 1 || vexRT[Btn6DXmtr2]) {
			bellymotor(-100);
		} else {
			bellymotor(0);
	  }
#if 0
	  // Belly control loop
	  if (vexRT[Btn7L] == 1) target_pot = BELLY_POT_FRONT;
	  if (vexRT[Btn7R] == 1) target_pot = BELLY_POT_REST;
	  if (vexRT[Btn7U] == 1) target_pot = BELLY_POT_MID;
	  short belly_pot_delta = target_pot - SensorValue(belly_angle);
	  short stim = belly_pot_delta / 20; // bpd can go from -2400 to 2400
	  bellymotor(stim);
#endif
	  // Arm loader
	  if (vexRT[Btn5U] == 1 || vexRT[Btn5UXmtr2]) {
	  	motor[M2] = 50; motor[M9] = -50;
	  } else if (vexRT[Btn5D] == 1 || vexRT[Btn5DXmtr2]) {
			motor[M2] = -50; motor[M9] = 50;
	  } else {
			motor[M2] = motor[M9] = 0;
		}

		// Gripper
		if (vexRT[Btn8R] == 1 || vexRT[Btn8RXmtr2]) {
			motor[M6] = 100;
		} else if (vexRT[Btn8L] == 1 || vexRT[Btn8LXmtr2]) {
			motor[M6] = -100;
	  } else {
	    motor[M6] = 0;
	  }

	}
}
