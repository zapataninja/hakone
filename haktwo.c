#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    linefollower,   sensorLineFollower)
#pragma config(Sensor, dgtl4,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  sonar_front,    sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  sonar_side,     sensorSONAR_cm)
#pragma config(Sensor, dgtl10, sonar_back,     sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           M1,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port3,           M3,            tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,           M5,            tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          M10,           tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*																																					 */
/*				MOTOR ASSIGNMENT TABLE																						 */
/*				M1 - Right Base Back																							 */
/*				M3 - Left Base Front (IME)																				 */
/*				M5 - Right Base Front (IME)																				 */
/*				M10 - Left Base Back																							 */
/*																																					 */
/*																																					 */
/*---------------------------------------------------------------------------*/

//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

/*---------------------------------------------------------------------------*/
/*																																					 */
/*				Description: Competition template for VEX EDR											 */
/*																																					 */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
//#include "Vex_Competition_Includes.c"


//HAKBOTS functions
void basemotor(short left, short right) {
	motor[M3] = left;
	motor[M1] = right;
	motor[M10] = left;
	motor[M5] = right;
}


/* Original - https://www.vexforum.com/index.php/6465-a-pid-controller-in-robotc*/
/*-----------------------------------------------------------------------------*/
/*																																						 */
/*	pid control task																													 */
/*																																						 */
/*-----------------------------------------------------------------------------*/


#define PID_DRIVE_MAX				50
#define PID_DRIVE_MIN			(-50)

#define PID_INTEGRAL_LIMIT	15
#define PID_ERROR_LIMIT 0

// These could be constants but leaving
// as variables allows them to be modified in the debugger "live"
float	 pid_Kp = 1.0;
float	 pid_Ki = 0.03;
float	 pid_Kd = 0.3;

static float pidRequestedXValue;
static float pidRequestedYValue;

task pidController()
{
	float	 pidSensorCurrentXValue; //side
	float  pidSensorCurrentYValue; //back

	float  pidError;
	float	 pidXError;
	float  pidYError;

	float	 pidLastError;
	float	 pidIntegral;
	float	 pidDerivative;
	float	 pidDrive;

	// Init the variables - thanks Glenn :)
	pidLastError	= 0;
	pidIntegral		= 0;

	while( true )
	{
		// Read the sensor value and scale
		pidSensorCurrentXValue = SensorValue(sonar_back);
		pidSensorCurrentYValue = SensorValue(sonar_side);

		if (pidSensorCurrentXValue < 0 || pidSensorCurrentYValue < 0) {
			wait1Msec(25);
			continue;
		}
		// calculate error
		pidXError = pidSensorCurrentXValue - pidRequestedXValue;
		pidYError = pidSensorCurrentYValue - pidRequestedYValue;

		pidError = sqrt((pidXError * pidXError) + (pidYError * pidYError)); // SQRT(X2 + Y2)

		if(abs(pidError) <= PID_ERROR_LIMIT) {
			break;
		}

		// If we are inside controlable window then integrate the error
		if( abs(pidError) < PID_INTEGRAL_LIMIT )
			pidIntegral = pidIntegral + pidError;
		else
			pidIntegral = 0;

		// calculate the derivative
		pidDerivative = pidError - pidLastError;
		pidLastError	= pidError;

		string string1 = "";
		string string2 = "";
		clearLCDLine(0);
		clearLCDLine(1);
		// send to motor use pidDrive
		sprintf(string1, "%2.2f, %2.2f, %2.2f", pidError, pidIntegral, pidDerivative);
		sprintf(string2, "%d, %d, %d", SensorValue(sonar_front), SensorValue(sonar_back), SensorValue(sonar_side));
		displayLCDString(0, 0, string1);
		displayLCDString(1, 0, string2);
		// calculate drive
		pidDrive = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

		// limit drive
		if( pidDrive > PID_DRIVE_MAX )
			pidDrive = PID_DRIVE_MAX;
		if( pidDrive < PID_DRIVE_MIN )
			pidDrive = PID_DRIVE_MIN;

		// send to motor
			if (abs(pidXError) > 0 && abs(pidYError) > 0) {
						basemotor(-1*pidDrive, pidDrive);
			}

			if (abs(pidXError) > 0 && abs(pidYError) == 0) {
					motor[M5] = pidDrive;
					motor[M3] = 10;
					motor[M1] = 10
					motor[M10] = 10;
			}

			if (abs(pidXError)== 0 && abs(pidYError) > 0) {
					motor[M5] = -1*pidDrive;
					motor[M3] = 10;
					motor[M1] = 10
					motor[M10] = 10;
			}

		// Run at 50Hz
		wait1Msec( 25 );
	}

	// clear all
	pidError			= 0;
	pidLastError	= 0;
	pidIntegral		= 0;
	pidDerivative = 0;
	basemotor(0, 0);
}


/***** get all sensor data on a new thread *****/
task get_sensor_data() {

	while(1) {

		string string1, string2;

		/**** get motor encoder data *****/
		clearLCDLine(0);
		clearLCDLine(1);
		// send to motor use pidDrive
		sprintf(string1, "%d, %d, %d", SensorValue(linefollower), nMotorEncoder[M3], nMotorEncoder[M5]);
		sprintf(string2, "%d, %d, %d", SensorValue(sonar_front),
		SensorValue(sonar_back), SensorValue(sonar_side));
		displayLCDString(0, 0, string1);
		displayLCDString(1, 0, string2);

		wait1Msec(300);
	}
}


/*---------------------------------------------------------------------------*/
/*													Pre-Autonomous Functions												 */
/*																																					 */
/*	You may want to perform some actions before the competition starts.			 */
/*	Do them in the following function.	You must return from this function	 */
/*	or the autonomous and usercontrol tasks will not be started.	This			 */
/*	function is only called once after the cortex has been powered on and		 */
/*	not every time that the robot is disabled.															 */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	//Initialize
	nMotorEncoder[M3] = 0;
	nMotorEncoder[M5] = 0;
	//kick off a thread for sensor data
	//if (bIfiRobotDisabled) {
	//	startTask(get_sensor_data, 20);
	//}
	return;
}

/*---------------------------------------------------------------------------*/
/*																																					 */
/*															Autonomous Task															 */
/*																																					 */
/*	This task is used to control your robot during the autonomous phase of	 */
/*	a VEX Competition.																											 */
/*																																					 */
/*	You must modify the code to add your own robot specific commands here.	 */
/*---------------------------------------------------------------------------*/
#define ARM_MOTOR_ZERO {motor[M2] = motor[M9] = 0;};

//do not set arm motor power to 127, otherwise it will thud and change alignment
#define ARM_MOTOR_DOWN {motor[M2] = -64; motor[M9] = 64;};
#define ARM_MOTOR_UP {motor[M2] = 64; motor[M9] = -64;};

#define BASE_MOTOR_FWD basemotor(20, -20);
#define BASE_MOTOR_BKD basemotor(-127, 127);
#define BASE_MOTOR_ZERO basemotor(0, 0);
#define BASE_MOTOR_CLOCKWISE basemotor(sign*127, sign*127);
#define BASE_MOTOR_COUNTERCLOCKWISE basemotor(-127*sign, -127*sign);

#define BELLY_MOTOR_DOWN {motor[M7] = -127; motor[M8] = 127;}
#define BELLY_MOTOR_UP {motor[M7] = 127; motor[M8] = -127;}
#define BELLY_MOTOR_ZERO {motor[M7] = motor[M8] = 0;}

#define CLAW_MOTOR_OPEN {motor[M6] = 127;}
#define CLAW_MOTOR_ZERO {motor[M6] = 0;}

task main() {
	bLCDBacklight = true;
	nMotorEncoder[M3] = 0;
	nMotorEncoder[M5] = 0;
	// send the motor off by some CM
	//initial 173, 290
	//final 190, 318

	//while(1) {
	//	get_sensor_data();
	//}

	float pidCurrentXValue = SensorValue(sonar_side);
	float pidCurrentYValue = SensorValue(sonar_back);
	pidRequestedXValue = pidCurrentXValue;
	pidRequestedYValue = 130;

	float rotationInDegrees = 90 - ((atan2((pidRequestedYValue - pidCurrentYValue), (pidRequestedXValue - pidCurrentXValue))) * 180/PI);
	float pidpostRotationXValue =  pidCurrentXValue * cosDegrees(rotationInDegrees);
	pidRequestedXValue = pidpostRotationXValue;
	pidRequestedYValue = SensorValue(sonar_back);

	// start the PID task
	startTask(pidController, 100);
	return;

}

/*---------------------------------------------------------------------------*/
/*																																					 */
/*															User Control Task														 */
/*																																					 */
/*	This task is used to control your robot during the user control phase of */
/*	a VEX Competition.																											 */
/*																																					 */
/*	You must modify the code to add your own robot specific commands here.	 */
/*---------------------------------------------------------------------------*/

short nonlinear(short val) {
	int square = val * abs(val);
	return (short) square / 127;
}

#define BELLY_POT_REST 725 // value of pot when loader is all the way back
#define BELLY_POT_FRONT 3275 // value of pot when loader is all the way front
#define BELLY_POT_MID	 2000

task usercontrol()
{

	//kick off a thread for sensor data
	//startTask(get_sensor_data, 20);


	// User control code here, inside the loop
	while (true)
	{
		// This is the main execution loop for the user control program.
		// Each time through the loop your program should update motor + servo
		// values based on feedback from the joysticks.

		// ........................................................................
		// Insert user code here. This is where you use the joystick values to
		// update your motors, etc.
		// ........................................................................

		// Remove this function call once you have "real" code.
		//UserControlCodePlaceholderForTesting();


		// Chassis motors
		short DEAD_ZONE = 15;
		short left;
		short right;
		short ch3 = vexRT[Ch3];// + vexRT[Ch3Xmtr2];
		short ch1 = vexRT[Ch1];// + vexRT[Ch1Xmtr2];

		if (abs(ch1) < DEAD_ZONE) {
			ch1 = 0;
		}

		if (abs(ch3) < DEAD_ZONE) {
			ch3 = 0;
		}

		short slow_factor = 1;
		ch1 = ch1 / slow_factor; // to make turning slower

		left = nonlinear(ch1 + ch3);
		right = nonlinear(ch1 - ch3);

		motor[M3] = left;
		motor[M1] = left;
		motor[M10] = right;
		motor[M5] = right;


#if 0
		// Belly control loop
		if (vexRT[Btn7L] == 1) target_pot = BELLY_POT_FRONT;
		if (vexRT[Btn7R] == 1) target_pot = BELLY_POT_REST;
		if (vexRT[Btn7U] == 1) target_pot = BELLY_POT_MID;
		short belly_pot_delta = target_pot - SensorValue(belly_angle);
		short stim = belly_pot_delta / 20; // bpd can go from -2400 to 2400
		bellymotor(stim);
#endif


	}
}
